# HMAC-Euclidean-Inverse
Message authentication can be done using publicly available unkeyed hash functions. The hash function used in this implementation is the SHA256. In the implementation a ket is shared between the parties and the key is split into inner and outer key by performing exclusive or operation with 0x36 (32 byte format of the hex ox363636..) for inner key and xor operation with 0x5c5c.. in the same way for the outer key generation. An iterated hashes that overcomes defects of length key extension attacks is used. The iteration prepends the inner key with the data and generates a message digest using the SHA256 hashing algorithm. The output is then prepended with the outer key to perform the same steps again for generating the message authentication code. Some one with the shared secret key can compute the hash of the message and confirm that the message is not tampered and authenticate the senders identity. Incontrast with digital signatures, every communicating parties should exchange shared secret key, which is not a scalable for large number of nodes as in the internet. All the logics needed for the HMAC implementation can be found in the class HMACSHA256 found in the question2/hmac_sha256.py file. Cryptography library hashes function is used to compute the SHA256 in the implementation. The logic for the HMAC implementation include generating inner and outer keys,  generating Hash message authentication code, and verifiying the HMAC codes.

The second  implementation includes the extended euclidean inverse implementation,, which is necessary for implementing elgamal public key cryptosystem which is implemented in the cryptography suite repository. The Euclidean algorithm calculates the GCD between two numbers iteratively by using the fact that GCF (a, b) = GCF (b, a%b) given b < a. The program given iteratively runs the algorithm forward to compute/mark the quotients necessary in the reverse process. Integer division at every step of the iteration to determine the quotients. Python supports large precision numbers and division takes a complexity O(n log n) for large integers. The next is running the algorithm in reverse by initializing s=1 and t=-q. Using the update term of t’ = s – tq and s=t until the last quotient value is read backwards. The last remaining value is the inverse in the multiplicative group.
